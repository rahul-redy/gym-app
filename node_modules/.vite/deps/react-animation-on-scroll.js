import {
  require_lodash
} from "./chunk-3KM6ONRM.js";
import {
  require_react
} from "./chunk-JFTBQ7A7.js";
import {
  __toESM
} from "./chunk-AC2VUBZ6.js";

// node_modules/react-animation-on-scroll/dist/esm/components/AnimationOnScroll.js
var import_react = __toESM(require_react());
var import_lodash = __toESM(require_lodash());
var animatedClass = "animate__animated";
var serverSide = typeof window === "undefined";
var scrollableParentRefInitialValue = void 0;
if (!serverSide) {
  scrollableParentRefInitialValue = window;
}
var AnimationOnScroll = ({
  offset = 150,
  duration = 1,
  style: styleProps,
  className: classNameProps,
  initiallyVisible = false,
  animateIn,
  afterAnimatedIn,
  animateOut,
  delay = 0,
  animatePreScroll = true,
  afterAnimatedOut,
  scrollableParentSelector,
  animateOnce = false,
  children
}) => {
  const [classes, setClasses] = (0, import_react.useState)(animatedClass);
  const [style, setStyle] = (0, import_react.useState)({
    animationDuration: `${duration}s`,
    opacity: initiallyVisible ? 1 : 0
  });
  const node = (0, import_react.useRef)(null);
  const animating = (0, import_react.useRef)(false);
  const visibilityRef = (0, import_react.useRef)({
    onScreen: false,
    inViewport: false
  });
  const delayedAnimationTORef = (0, import_react.useRef)(void 0);
  const callbackTORef = (0, import_react.useRef)(void 0);
  const scrollableParentRef = (0, import_react.useRef)(scrollableParentRefInitialValue);
  const getElementTop = (0, import_react.useCallback)((elm) => {
    let yPos = 0;
    while (elm && elm.offsetTop !== void 0 && elm.clientTop !== void 0) {
      yPos += elm.offsetTop + elm.clientTop;
      elm = elm.offsetParent;
    }
    return yPos;
  }, []);
  const getScrollPos = (0, import_react.useCallback)(() => {
    if (scrollableParentRef.current.pageYOffset !== void 0) {
      return scrollableParentRef.current.pageYOffset;
    }
    return scrollableParentRef.current.scrollTop;
  }, [scrollableParentRef]);
  const getScrollableParentHeight = (0, import_react.useCallback)(() => {
    if (scrollableParentRef.current.innerHeight !== void 0) {
      return scrollableParentRef.current.innerHeight;
    }
    return scrollableParentRef.current.clientHeight;
  }, [scrollableParentRef]);
  const getViewportTop = (0, import_react.useCallback)(() => {
    return getScrollPos() + offset;
  }, [offset, getScrollPos]);
  const getViewportBottom = (0, import_react.useCallback)(() => {
    return getScrollPos() + getScrollableParentHeight() - offset;
  }, [offset, getScrollPos, getScrollableParentHeight]);
  const isInViewport = (0, import_react.useCallback)((y) => {
    return y >= getViewportTop() && y <= getViewportBottom();
  }, [getViewportTop, getViewportBottom]);
  const isAboveViewport = (0, import_react.useCallback)((y) => {
    return y < getViewportTop();
  }, [getViewportTop]);
  const isBelowViewport = (0, import_react.useCallback)((y) => {
    return y > getViewportBottom();
  }, [getViewportBottom]);
  const inViewport = (0, import_react.useCallback)((elementTop, elementBottom) => {
    return isInViewport(elementTop) || isInViewport(elementBottom) || isAboveViewport(elementTop) && isBelowViewport(elementBottom);
  }, [isInViewport, isAboveViewport, isBelowViewport]);
  const isAboveScreen = (0, import_react.useCallback)((y) => {
    return y < getScrollPos();
  }, [getScrollPos]);
  const isBelowScreen = (0, import_react.useCallback)((y) => {
    return y > getScrollPos() + getScrollableParentHeight();
  }, [getScrollPos, getScrollableParentHeight]);
  const onScreen = (0, import_react.useCallback)((elementTop, elementBottom) => {
    return !isAboveScreen(elementBottom) && !isBelowScreen(elementTop);
  }, [isAboveScreen, isBelowScreen]);
  const getVisibility = (0, import_react.useCallback)(() => {
    const elementTop = getElementTop(node.current) - getElementTop(scrollableParentRef.current);
    const elementBottom = elementTop + node.current.clientHeight;
    return {
      inViewport: inViewport(elementTop, elementBottom),
      onScreen: onScreen(elementTop, elementBottom)
    };
  }, [getElementTop, node, inViewport, onScreen, scrollableParentRef]);
  const visibilityHasChanged = (0, import_react.useCallback)((previousVis, currentVis) => {
    return previousVis.inViewport !== currentVis.inViewport || previousVis.onScreen !== currentVis.onScreen;
  }, []);
  const animate = (0, import_react.useCallback)((animation, callback) => {
    delayedAnimationTORef.current = setTimeout(() => {
      animating.current = true;
      setClasses(`${animatedClass} ${animation}`);
      setStyle({
        animationDuration: `${duration}s`
      });
      callbackTORef.current = setTimeout(callback, duration * 1e3);
    }, delay);
  }, [animating, delay, duration]);
  const animateInTrigger = (0, import_react.useCallback)((callback) => {
    animate(animateIn, () => {
      if (!animateOnce) {
        setStyle({
          animationDuration: `${duration}s`,
          opacity: 1
        });
        animating.current = false;
      }
      const vis = getVisibility();
      if (callback) {
        callback(vis);
      }
    });
  }, [animating, animateIn, animateOnce, duration, animate, getVisibility]);
  const animateOutTrigger = (0, import_react.useCallback)((callback) => {
    animate(animateOut, () => {
      setClasses(animatedClass);
      setStyle({
        animationDuration: `${duration}s`,
        opacity: 0
      });
      const vis = getVisibility();
      if (vis.inViewport && animateIn) {
        animateInTrigger(afterAnimatedIn);
      } else {
        animating.current = false;
      }
      if (callback) {
        callback(vis);
      }
    });
  }, [animating, animate, animateIn, duration, afterAnimatedIn, animateInTrigger, animateOut, getVisibility]);
  const handleScroll = (0, import_react.useCallback)(() => {
    if (!animating.current) {
      const {
        current: visibility
      } = visibilityRef;
      const currentVis = getVisibility();
      if (visibilityHasChanged(visibility, currentVis)) {
        clearTimeout(delayedAnimationTORef.current);
        if (!currentVis.onScreen) {
          setClasses(animatedClass);
          setStyle({
            animationDuration: `${duration}s`,
            opacity: initiallyVisible ? 1 : 0
          });
        } else if (currentVis.inViewport && animateIn) {
          animateInTrigger(afterAnimatedIn);
        } else if (currentVis.onScreen && visibility.inViewport && animateOut && node.current.style.opacity === "1") {
          animateOutTrigger(afterAnimatedOut);
        }
        visibilityRef.current = currentVis;
      }
    }
  }, [afterAnimatedIn, afterAnimatedOut, animateIn, animateInTrigger, animateOut, duration, initiallyVisible, visibilityHasChanged, animateOutTrigger, getVisibility]);
  const listener = (0, import_react.useMemo)(() => (0, import_lodash.default)(() => {
    handleScroll();
  }, 50), [handleScroll]);
  (0, import_react.useEffect)(() => {
    if (!serverSide) {
      const parentSelector = scrollableParentSelector;
      scrollableParentRef.current = parentSelector ? document.querySelector(parentSelector) : window;
      if (scrollableParentRef.current && scrollableParentRef.current.addEventListener) {
        scrollableParentRef.current.addEventListener("scroll", listener);
      } else {
        console.warn(`Cannot find element by locator: ${scrollableParentSelector}`);
      }
      if (animatePreScroll) {
        handleScroll();
      }
      return () => {
        clearTimeout(delayedAnimationTORef.current);
        clearTimeout(callbackTORef.current);
        if (window && window.removeEventListener) {
          window.removeEventListener("scroll", listener);
        }
      };
    }
  }, [handleScroll, scrollableParentSelector, scrollableParentRef, listener, animatePreScroll]);
  return import_react.default.createElement("div", {
    ref: node,
    className: classNameProps ? `${classNameProps} ${classes}` : classes,
    style: Object.assign({}, style, styleProps)
  }, children);
};
export {
  AnimationOnScroll
};
//# sourceMappingURL=react-animation-on-scroll.js.map
